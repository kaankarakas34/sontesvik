const { Application, User, ConsultantAssignmentLog, ConsultantReview } = require('../models');
const ConsultantAssignmentService = require('../services/consultantAssignmentService');
const ApplicationRoomService = require('../services/applicationRoomService');
const { Op } = require('sequelize');

class ConsultantController {
  /**
   * T√ºm danƒ±≈ümanlarƒ± listele (Admin i√ßin)
   */
  static async getAllConsultants(req, res) {
    try {
      const { page = 1, limit = 10, sector, status, search } = req.query;
      const offset = (page - 1) * limit;

      const whereClause = {
        role: 'consultant'
      };

      if (sector) whereClause.sector = sector;
      if (status) whereClause.consultantStatus = status;
      if (search) {
        whereClause[Op.or] = [
          { firstName: { [Op.iLike]: `%${search}%` } },
          { lastName: { [Op.iLike]: `%${search}%` } },
          { email: { [Op.iLike]: `%${search}%` } }
        ];
      }

      const consultants = await User.findAndCountAll({
        where: whereClause,
        include: [
          {
            model: Application,
            as: 'assignedApplications',
            where: {
              status: ['pending', 'under_review', 'additional_info_required']
            },
            required: false
          }
        ],
        attributes: {
          exclude: ['password', 'refreshToken', 'passwordResetToken', 'passwordResetExpires']
        },
        limit: parseInt(limit),
        offset: parseInt(offset),
        order: [['createdAt', 'DESC']]
      });

      // Danƒ±≈üman y√ºklerini hesapla
      const consultantsWithLoad = consultants.rows.map(consultant => {
        const consultantData = consultant.toJSON();
        const activeApplications = consultantData.assignedApplications?.length || 0;
        
        return {
          ...consultantData,
          activeApplications,
          loadPercentage: (activeApplications / consultantData.maxConcurrentApplications) * 100,
          canAcceptMore: activeApplications < consultantData.maxConcurrentApplications
        };
      });

      res.json({
        success: true,
        data: {
          consultants: consultantsWithLoad,
          pagination: {
            total: consultants.count,
            page: parseInt(page),
            limit: parseInt(limit),
            totalPages: Math.ceil(consultants.count / limit)
          }
        }
      });

    } catch (error) {
      console.error('‚ùå Danƒ±≈üman listeleme hatasƒ±:', error);
      res.status(500).json({
        success: false,
        message: 'Danƒ±≈ümanlar listelenemedi',
        error: error.message
      });
    }
  }

  /**
   * Danƒ±≈üman dashboard verilerini getir
   */
  static async getConsultantDashboard(req, res) {
    try {
      const consultantId = req.user.id;

      // Danƒ±≈üman bilgilerini getir
      const consultant = await User.findByPk(consultantId, {
        attributes: {
          exclude: ['password', 'refreshToken', 'passwordResetToken', 'passwordResetExpires']
        }
      });

      if (!consultant || !consultant.isConsultant()) {
        return res.status(403).json({
          success: false,
          message: 'Bu i≈ülem i√ßin yetkiniz yok'
        });
      }

      // Atanmƒ±≈ü ba≈üvurularƒ± getir
      const assignedApplications = await Application.findAll({
        where: { assignedConsultantId: consultantId },
        order: [['createdAt', 'DESC']],
        include: [
          { model: User, as: 'user', attributes: ['id','firstName','lastName','email','companyName'] },
          { model: require('../models').Incentive, as: 'incentive', attributes: ['id','title','description'] }
        ]
      });

      // Danƒ±≈üman deƒüerlendirmelerini getir - ≈üimdilik bo≈ü array d√∂nd√ºr  
      const consultantReviews = [];

      if (!consultant || !consultant.isConsultant()) {
        return res.status(403).json({
          success: false,
          message: 'Bu i≈ülem i√ßin yetkiniz yok'
        });
      }

      // ƒ∞statistikleri hesapla
      const applications = assignedApplications || [];
      const stats = {
        totalApplications: applications.length,
        pendingApplications: applications.filter(app => app.status === 'pending').length,
        underReviewApplications: applications.filter(app => app.status === 'under_review').length,
        approvedApplications: applications.filter(app => app.status === 'approved').length,
        rejectedApplications: applications.filter(app => app.status === 'rejected').length,
        averageRating: consultant.consultantRating || 0,
        reviewCount: consultant.consultantReviewCount || 0,
        loadPercentage: (applications.filter(app => ['pending', 'under_review'].includes(app.status)).length / consultant.maxConcurrentApplications) * 100
      };

      // Son 7 g√ºn i√ßin ba≈üvuru trendi
      const last7Days = await ConsultantController.getLast7DaysStats(consultantId);

      // Aktif ba≈üvurular (son 30 g√ºn)
      const activeApplications = applications.filter(app => {
        const appDate = new Date(app.createdAt);
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        return appDate >= thirtyDaysAgo;
      }).slice(0, 10); // ƒ∞lk 10'u g√∂ster

      res.json({
        success: true,
        data: {
          assignedApplications: applications,
          stats,
          weeklyStats: last7Days,
          recentReviews: consultantReviews,
          consultant: consultant.toJSON(),
        }
      });

    } catch (error) {
      console.error('‚ùå Danƒ±≈üman dashboard hatasƒ±:', error);
      res.status(500).json({
        success: false,
        message: 'Dashboard verileri alƒ±namadƒ±',
        error: error.message
      });
    }
  }

  /**
   * Son 7 g√ºn i√ßin istatistikler
   */
  static async getLast7DaysStats(consultantId) {
    const last7Days = [];
    const today = new Date();

    for (let i = 6; i >= 0; i--) {
      const date = new Date();
      date.setDate(today.getDate() - i);
      date.setHours(0, 0, 0, 0);
      
      const nextDate = new Date(date);
      nextDate.setDate(nextDate.getDate() + 1);

      const dayStats = await Application.findAll({
        where: {
          assignedConsultantId: consultantId,
          createdAt: {
            [Op.between]: [date, nextDate]
          }
        },
        attributes: ['status']
      });

      last7Days.push({
        date: date.toISOString().split('T')[0],
        total: dayStats.length,
        pending: dayStats.filter(s => s.status === 'pending').length,
        underReview: dayStats.filter(s => s.status === 'under_review').length,
        approved: dayStats.filter(s => s.status === 'approved').length,
        rejected: dayStats.filter(s => s.status === 'rejected').length
      });
    }

    return last7Days;
  }

  /**
   * Danƒ±≈ümanƒ±n atanan ba≈üvurularƒ±nƒ± getir
   */
  static async getAssignedApplications(req, res) {
    try {
      const consultantId = req.user.id;
      const { status, page = 1, limit = 10, search } = req.query;
      const offset = (page - 1) * limit;

      const whereClause = {
        assignedConsultantId: consultantId
      };

      if (status) whereClause.status = status;
      if (search) {
        whereClause[Op.or] = [
          { applicationNumber: { [Op.iLike]: `%${search}%` } },
          { projectTitle: { [Op.iLike]: `%${search}%` } }
        ];
      }

      const applications = await Application.findAndCountAll({
        where: whereClause,
        include: [
          {
            model: User,
            as: 'user',
            attributes: ['id', 'firstName', 'lastName', 'email', 'companyName', 'sector', 'phone']
          },
          {
            model: require('../models/Incentive'),
            as: 'incentive'
          }
        ],
        order: [['createdAt', 'DESC']],
        limit: parseInt(limit),
        offset: parseInt(offset)
      });

      // Basic logging for debugging incoming/outgoing data
      try {
        console.log('üë§ Consultant assigned applications fetched', {
          consultantId,
          query: { status, page: Number(page), limit: Number(limit), search: search || null },
          total: applications.count,
          applicationIds: applications.rows.map(a => a.id)
        });
      } catch (_) { /* no-op */ }

      res.json({
        success: true,
        data: {
          applications: applications.rows,
          pagination: {
            total: applications.count,
            page: parseInt(page),
            limit: parseInt(limit),
            totalPages: Math.ceil(applications.count / limit)
          }
        }
      });

    } catch (error) {
      console.error('‚ùå Atanmƒ±≈ü ba≈üvurular getirme hatasƒ±:', error);
      res.status(500).json({
        success: false,
        message: 'Ba≈üvurular getirilemedi',
        error: error.message
      });
    }
  }

  /**
   * Ba≈üvuru detaylarƒ±nƒ± getir
   */
  static async getApplicationDetails(req, res) {
    try {
      const { applicationId } = req.params;
      const consultantId = req.user.id;

      const application = await Application.findOne({
        where: {
          id: applicationId,
          assignedConsultantId: consultantId
        },
        include: [
          {
            model: User,
            as: 'user',
            attributes: ['id', 'firstName', 'lastName', 'email', 'companyName', 'sector', 'phone', 'address']
          },
          {
            model: require('../models/Incentive'),
            as: 'incentive'
          },
          {
            model: require('../models/Document'),
            as: 'documents'
          }
        ]
      });

      if (!application) {
        return res.status(404).json({
          success: false,
          message: 'Ba≈üvuru bulunamadƒ± veya size atanmamƒ±≈ü'
        });
      }

      res.json({
        success: true,
        data: { application }
      });

    } catch (error) {
      console.error('‚ùå Ba≈üvuru detayƒ± getirme hatasƒ±:', error);
      res.status(500).json({
        success: false,
        message: 'Ba≈üvuru detayƒ± getirilemedi',
        error: error.message
      });
    }
  }

  /**
   * Ba≈üvuru durumunu g√ºncelle
   */
  static async updateApplicationStatus(req, res) {
    try {
      const { applicationId } = req.params;
      const { status, consultantNotes, consultantRating, consultantReview } = req.body;
      const consultantId = req.user.id;

      const application = await Application.findOne({
        where: {
          id: applicationId,
          assignedConsultantId: consultantId
        }
      });

      if (!application) {
        return res.status(404).json({
          success: false,
          message: 'Ba≈üvuru bulunamadƒ± veya size atanmamƒ±≈ü'
        });
      }

      // Durum ge√ßi≈ülerini kontrol et
      const validTransitions = {
        'pending': ['under_review', 'additional_info_required'],
        'under_review': ['approved', 'rejected', 'additional_info_required'],
        'additional_info_required': ['under_review']
      };

      if (!validTransitions[application.status]?.includes(status)) {
        return res.status(400).json({
          success: false,
          message: `Ge√ßersiz durum ge√ßi≈üi: ${application.status} -> ${status}`
        });
      }

      const updateData = {
        status,
        consultantNotes: consultantNotes || application.consultantNotes,
        consultantRating: consultantRating || application.consultantRating,
        consultantReview: consultantReview || application.consultantReview
      };

      // Duruma g√∂re tarih alanlarƒ±nƒ± g√ºncelle
      if (status === 'under_review') {
        updateData.reviewedAt = new Date();
        updateData.reviewedBy = consultantId;
      } else if (status === 'approved') {
        updateData.approvedAt = new Date();
        updateData.approvedBy = consultantId;
      } else if (status === 'rejected') {
        updateData.rejectedAt = new Date();
      }

      await application.update(updateData);

      // Room durumunu da g√ºncelle
      await ApplicationRoomService.updateRoomOnApplicationStatusChange(
        applicationId, 
        status, 
        consultantId
      );

      res.json({
        success: true,
        message: 'Ba≈üvuru durumu ba≈üarƒ±yla g√ºncellendi',
        data: { application }
      });

    } catch (error) {
      console.error('‚ùå Ba≈üvuru durumu g√ºncelleme hatasƒ±:', error);
      res.status(500).json({
        success: false,
        message: 'Ba≈üvuru durumu g√ºncellenemedi',
        error: error.message
      });
    }
  }

  /**
   * Danƒ±≈üman performans istatistikleri
   */
  static async getConsultantPerformance(req, res) {
    try {
      const { consultantId } = req.params;
      const { startDate, endDate } = req.query;

      // Sadece admin ve danƒ±≈üman kendisi g√∂rebilir
      if (req.user.role !== 'admin' && req.user.id !== consultantId) {
        return res.status(403).json({
          success: false,
          message: 'Bu verileri g√∂rme yetkiniz yok'
        });
      }

      const stats = await ConsultantAssignmentService.getConsultantStats(consultantId);
      
      if (!stats.success) {
        return res.status(404).json({
          success: false,
          message: stats.message
        });
      }

      res.json({
        success: true,
        data: stats
      });

    } catch (error) {
      console.error('‚ùå Danƒ±≈üman performans hatasƒ±:', error);
      res.status(500).json({
        success: false,
        message: 'Performans verileri alƒ±namadƒ±',
        error: error.message
      });
    }
  }

  /**
   * Yeni danƒ±≈üman olu≈ütur (Admin i√ßin)
   */
  static async createConsultant(req, res) {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          message: 'Bu i≈ülem i√ßin admin yetkisi gerekli'
        });
      }

      const {
        firstName,
        lastName,
        email,
        phone,
        sector,
        consultantBio,
        consultantSpecializations,
        maxConcurrentApplications = 10
      } = req.body;

      // Email kontrol√º
      const existingUser = await User.findOne({ where: { email } });
      if (existingUser) {
        return res.status(400).json({
          success: false,
          message: 'Bu email adresi zaten kullanƒ±mda'
        });
      }

      // Ge√ßici ≈üifre olu≈ütur
      const tempPassword = Math.random().toString(36).slice(-8);

      const consultant = await User.create({
        firstName,
        lastName,
        email,
        password: tempPassword,
        phone,
        role: 'consultant',
        sector,
        consultantBio,
        consultantSpecializations: consultantSpecializations || [],
        maxConcurrentApplications,
        isApproved: true,
        isActive: true,
        consultantStatus: 'active',
        assignedBy: req.user.id,
        assignedAt: new Date()
      });

      res.json({
        success: true,
        message: 'Danƒ±≈üman ba≈üarƒ±yla olu≈üturuldu',
        data: {
          consultant: {
            id: consultant.id,
            firstName: consultant.firstName,
            lastName: consultant.lastName,
            email: consultant.email,
            tempPassword // ƒ∞lk giri≈ü i√ßin ge√ßici ≈üifre
          }
        }
      });

    } catch (error) {
      console.error('‚ùå Danƒ±≈üman olu≈üturma hatasƒ±:', error);
      res.status(500).json({
        success: false,
        message: 'Danƒ±≈üman olu≈üturulamadƒ±',
        error: error.message
      });
    }
  }
}

module.exports = ConsultantController;