name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: 'false'
        type: boolean

env:
  SERVER_HOST: 72.61.17.133
  SERVER_USER: root
  PROJECT_DIR: /opt/tesvik360

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: |
            backend/package-lock.json
            web/package-lock.json

      - name: Install backend dependencies
        run: |
          cd backend
          npm ci

      - name: Install frontend dependencies
        run: |
          cd web
          npm ci

      - name: Run backend tests
        run: |
          cd backend
          npm test || echo "Backend tests failed but continuing..."

      - name: Build frontend
        run: |
          cd web
          npm run build

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: test
    if: always() && (needs.test.result == 'success' || github.event.inputs.force_deploy == 'true')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create project directory
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "mkdir -p ${{ env.PROJECT_DIR }}"

      - name: Copy files to server
        run: |
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='dist' \
            --exclude='build' \
            --exclude='.env' \
            --exclude='*.log' \
            ./ ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.PROJECT_DIR }}/

      - name: Copy environment file
        run: |
          scp .env.production ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.PROJECT_DIR }}/.env

      - name: Make deploy script executable
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "chmod +x ${{ env.PROJECT_DIR }}/deploy.sh"

      - name: Install Docker and Docker Compose (if needed)
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
              systemctl enable docker
              systemctl start docker
            fi
            
            # Check if Docker Compose is installed
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing Docker Compose..."
              curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose
            fi
            
            echo "Docker version: $(docker --version)"
            echo "Docker Compose version: $(docker-compose --version)"
          EOF

      - name: Deploy application
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
            cd ${{ env.PROJECT_DIR }}
            ./deploy.sh deploy
          EOF

      - name: Health check
        run: |
          echo "Waiting for services to start..."
          sleep 60
          
          # Check if services are running
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
            cd ${{ env.PROJECT_DIR }}
            
            echo "Checking service status..."
            docker-compose -f docker-compose.prod.yml ps
            
            echo "Checking backend health..."
            if curl -f http://localhost/api/health; then
              echo "âœ… Backend is healthy"
            else
              echo "âŒ Backend health check failed"
              exit 1
            fi
            
            echo "Checking frontend..."
            if curl -f http://localhost/; then
              echo "âœ… Frontend is accessible"
            else
              echo "âŒ Frontend is not accessible"
              exit 1
            fi
          EOF

      - name: Cleanup old Docker images
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
            echo "Cleaning up old Docker images..."
            docker image prune -f
            docker system prune -f
          EOF

      - name: Send deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Deployment successful!"
            echo "ðŸŒ Application is available at: http://${{ env.SERVER_HOST }}"
          else
            echo "âŒ Deployment failed!"
          fi

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback deployment
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'EOF'
            cd ${{ env.PROJECT_DIR }}
            
            echo "ðŸ”„ Rolling back deployment..."
            
            # Stop current containers
            docker-compose -f docker-compose.prod.yml down
            
            # Find latest backup
            LATEST_BACKUP=$(ls -t /opt/tesvik360-backups/ | head -n1)
            
            if [ -n "$LATEST_BACKUP" ]; then
              echo "ðŸ“¦ Restoring from backup: $LATEST_BACKUP"
              
              # Restore database if backup exists
              if [ -f "/opt/tesvik360-backups/$LATEST_BACKUP/database.sql" ]; then
                docker-compose -f docker-compose.prod.yml up -d postgres
                sleep 10
                docker exec -i tesvik360-postgres psql -U tesvik360_user tesvik360 < "/opt/tesvik360-backups/$LATEST_BACKUP/database.sql"
              fi
              
              # Restore uploads if backup exists
              if [ -d "/opt/tesvik360-backups/$LATEST_BACKUP/uploads" ]; then
                cp -r "/opt/tesvik360-backups/$LATEST_BACKUP/uploads" backend/
              fi
            fi
            
            echo "âŒ Rollback completed. Please check the application manually."
          EOF