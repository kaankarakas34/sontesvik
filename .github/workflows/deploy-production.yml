name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (tag or branch)'
        required: true
        default: 'main'
        type: string
      skip-backup:
        description: 'Skip backup before deployment'
        required: false
        default: false
        type: boolean
      rollback:
        description: 'Rollback to previous version'
        required: false
        default: false
        type: boolean

  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}/backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  # Pre-deployment checks
  pre-deployment-checks:
    runs-on: ubuntu-latest
    name: Pre-deployment Checks
    if: ${{ !inputs.rollback }}
    
    outputs:
      health-check: ${{ steps.health.outputs.status }}
      backup-needed: ${{ steps.backup-check.outputs.needed }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.version || github.ref }}

    - name: Validate deployment configuration
      run: |
        echo "üîç Validating deployment configuration..."
        
        # Check if required files exist
        required_files=(
          "docker-compose.prod.yml"
          "nginx/nginx.conf"
          ".env.production"
          "scripts/deploy.sh"
          "scripts/backup.sh"
        )
        
        for file in "${required_files[@]}"; do
          if [ ! -f "$file" ]; then
            echo "‚ùå Required file missing: $file"
            exit 1
          fi
        done
        
        echo "‚úÖ All required files present"

    - name: Check production server health
      id: health
      run: |
        if curl -f -s ${{ secrets.DEPLOY_URL }}/api/health > /dev/null; then
          echo "status=healthy" >> $GITHUB_OUTPUT
          echo "‚úÖ Production server is healthy"
        else
          echo "status=unhealthy" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è Production server health check failed"
        fi

    - name: Check if backup is needed
      id: backup-check
      run: |
        if [ "${{ inputs.skip-backup }}" = "true" ]; then
          echo "needed=false" >> $GITHUB_OUTPUT
          echo "‚è≠Ô∏è Backup skipped by user request"
        else
          echo "needed=true" >> $GITHUB_OUTPUT
          echo "üíæ Backup will be created before deployment"
        fi

  # Create backup
  create-backup:
    runs-on: ubuntu-latest
    name: Create Backup
    needs: [pre-deployment-checks]
    if: ${{ needs.pre-deployment-checks.outputs.backup-needed == 'true' && !inputs.rollback }}
    
    steps:
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

    - name: Create production backup
      run: |
        ssh ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'EOF'
          cd ${{ secrets.DEPLOY_PATH }}
          
          echo "üì¶ Creating backup before deployment..."
          ./scripts/backup.sh
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Backup created successfully"
          else
            echo "‚ùå Backup failed"
            exit 1
          fi
        EOF

  # Deploy to production
  deploy:
    runs-on: ubuntu-latest
    name: Deploy to Production
    needs: [pre-deployment-checks, create-backup]
    if: ${{ always() && (needs.pre-deployment-checks.result == 'success' || inputs.rollback) }}
    environment: 
      name: production
      url: ${{ secrets.DEPLOY_URL }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.version || github.ref }}

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

    - name: Add server to known hosts
      run: |
        ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts

    - name: Deploy to production (Normal)
      if: ${{ !inputs.rollback }}
      run: |
        ssh ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'EOF'
          cd ${{ secrets.DEPLOY_PATH }}
          
          echo "üöÄ Starting deployment to production..."
          
          # Pull latest code
          git fetch --all
          git checkout ${{ inputs.version || 'main' }}
          git pull origin ${{ inputs.version || 'main' }}
          
          # Login to GitHub Container Registry
          echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          # Determine image tag
          if [[ "${{ inputs.version }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            IMAGE_TAG="${{ inputs.version }}"
          else
            IMAGE_TAG="latest"
          fi
          
          # Update docker-compose with correct image tags
          sed -i "s|ghcr.io/${{ github.repository }}/backend:.*|ghcr.io/${{ github.repository }}/backend:${IMAGE_TAG}|g" docker-compose.prod.yml
          sed -i "s|ghcr.io/${{ github.repository }}/frontend:.*|ghcr.io/${{ github.repository }}/frontend:${IMAGE_TAG}|g" docker-compose.prod.yml
          
          # Pull latest images
          docker-compose -f docker-compose.prod.yml pull
          
          # Deploy with zero downtime
          ./scripts/deploy.sh deploy
          
          echo "‚úÖ Deployment completed successfully"
        EOF

    - name: Deploy to production (Rollback)
      if: ${{ inputs.rollback }}
      run: |
        ssh ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'EOF'
          cd ${{ secrets.DEPLOY_PATH }}
          
          echo "üîÑ Starting rollback..."
          ./scripts/deploy.sh rollback
          
          echo "‚úÖ Rollback completed successfully"
        EOF

  # Post-deployment verification
  post-deployment-checks:
    runs-on: ubuntu-latest
    name: Post-deployment Checks
    needs: [deploy]
    if: ${{ always() && needs.deploy.result == 'success' }}
    
    steps:
    - name: Wait for services to start
      run: |
        echo "‚è≥ Waiting for services to start..."
        sleep 60

    - name: Health check
      run: |
        echo "üè• Performing health checks..."
        
        # API Health Check
        if curl -f -s ${{ secrets.DEPLOY_URL }}/api/health; then
          echo "‚úÖ API health check passed"
        else
          echo "‚ùå API health check failed"
          exit 1
        fi
        
        # Frontend Check
        if curl -f -s ${{ secrets.DEPLOY_URL }}/ > /dev/null; then
          echo "‚úÖ Frontend health check passed"
        else
          echo "‚ùå Frontend health check failed"
          exit 1
        fi

    - name: Performance check
      run: |
        echo "‚ö° Performing performance checks..."
        
        # Check API response time
        response_time=$(curl -o /dev/null -s -w '%{time_total}' ${{ secrets.DEPLOY_URL }}/api/health)
        
        if (( $(echo "$response_time < 2.0" | bc -l) )); then
          echo "‚úÖ API response time: ${response_time}s (Good)"
        else
          echo "‚ö†Ô∏è API response time: ${response_time}s (Slow)"
        fi

    - name: Database connectivity check
      run: |
        ssh ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'EOF'
          cd ${{ secrets.DEPLOY_PATH }}
          
          echo "üóÑÔ∏è Checking database connectivity..."
          
          # Check if database container is running
          if docker-compose -f docker-compose.prod.yml ps postgres | grep -q "Up"; then
            echo "‚úÖ Database container is running"
          else
            echo "‚ùå Database container is not running"
            exit 1
          fi
          
          # Check database connection from backend
          if docker-compose -f docker-compose.prod.yml exec -T backend npm run db:check 2>/dev/null; then
            echo "‚úÖ Database connection successful"
          else
            echo "‚ö†Ô∏è Database connection check skipped (command not available)"
          fi
        EOF

  # Cleanup
  cleanup:
    runs-on: ubuntu-latest
    name: Cleanup
    needs: [post-deployment-checks]
    if: ${{ always() }}
    
    steps:
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

    - name: Cleanup old images and containers
      run: |
        ssh ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'EOF'
          cd ${{ secrets.DEPLOY_PATH }}
          
          echo "üßπ Cleaning up old images and containers..."
          
          # Remove unused images (keep last 3 versions)
          docker image prune -f
          
          # Remove old containers
          docker container prune -f
          
          # Remove unused volumes (be careful with this)
          # docker volume prune -f
          
          echo "‚úÖ Cleanup completed"
        EOF

  # Notification
  notify:
    runs-on: ubuntu-latest
    name: Send Notification
    needs: [deploy, post-deployment-checks, cleanup]
    if: ${{ always() }}
    
    steps:
    - name: Determine deployment status
      id: status
      run: |
        if [ "${{ needs.deploy.result }}" = "success" ] && [ "${{ needs.post-deployment-checks.result }}" = "success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=‚úÖ Deployment successful" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=‚ùå Deployment failed" >> $GITHUB_OUTPUT
        fi

    - name: Create deployment summary
      run: |
        echo "## üöÄ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Status:** ${{ steps.status.outputs.message }}" >> $GITHUB_STEP_SUMMARY
        echo "**Version:** ${{ inputs.version || github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "**Deployment time:** $(date -u)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Application URL:** ${{ secrets.DEPLOY_URL }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Job Results" >> $GITHUB_STEP_SUMMARY
        echo "- Pre-deployment checks: ${{ needs.pre-deployment-checks.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Backup: ${{ needs.create-backup.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Deployment: ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Post-deployment checks: ${{ needs.post-deployment-checks.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Cleanup: ${{ needs.cleanup.result }}" >> $GITHUB_STEP_SUMMARY